import os   # To access directories
from csv import reader  # To read label data
import pickle   # To store processed data to save time
import numpy as np  # For data processing
import cv2  # To read images
from sklearn import svm     # To create the SVM model
from matplotlib import pyplot as plt    # To generate figures
from sklearn.metrics import plot_confusion_matrix   # To generate confusion matrices
from sklearn import model_selection     # To use the train test split function

# Main function called from the main file
def main(sel, model, cfm):
    if sel==0:  # User input arg 1 - Selects which mode to use: Arg1==0 creates the model to use
        print("Task B2: Eye Colour Recognition")
        model = create_model()  # Create model function called to create model object with desired parameters

        return model    # Returns model object to main file
    elif sel==1:    # User input arg 1 - Arg1==1 trains the model and validates it
        directory = 'cartoon_set/'  # Directory of the dataset for training
        y_name, y_eye, y_shp, all_index, list_col = import_data(directory)  # Imports data from csv file as well as pickle file if found. If not, then the data is generated by this function.
        x_use, y_use = process(all_index, list_col, y_eye)  # Using all_index (list of usable images), x and y data is extracted for each usable image
        print("Number of non-obscured eyes: ", len(y_use))
        x_train, x_vald, y_train, y_vald = model_selection.train_test_split(x_use, y_use, train_size=0.8, random_state=0)   # x,y data is split with a gives percentage and seed
        print("Number of training samples: ", len(x_train))
        model = train_model(model, x_train, y_train)    # Model is trained using x and y training data
        print("Number of validation samples: ", len(x_vald))
        accuracy = test_model(model, x_vald, y_vald)    # Model is validated using x and y validation data
        print("Accuracy of validation set: ", str(accuracy), "\n")
        if cfm==1:  # Use input arg 3 - Arg1==1 plots the confusion matrix
            disp = plot_confusion_matrix(model, x_vald, y_vald, cmap=plt.cm.Blues)  # Generate confusion matrix
            print(disp.confusion_matrix)
            plt.show()

        return accuracy     # Returns the accuracy of the model using validation data to main file
    elif sel==2:    # User input arg 1 - Arg1==2 tests the model using a test set of data
        directory = 'cartoon_set_test/'     # Directory of dataset for testing
        y_name, y_eye, y_shp, all_index, list_col = import_data(directory)  # Imports data from csv file as well as pickle file if found. If not, then the data is generated by this function.
        x_use, y_use = process(all_index, list_col, y_eye)  # Using all_index (list of usable images), x and y data is extracted for each usable image
        print("Number of non-obscured eyes: ", len(y_use))
        print("Number of test samples: ", len(y_use))
        accuracy = test_model(model, x_use, y_use)  # Model is tested using x and y test data
        print("Accuracy of unseen test set: ", str(accuracy), "\n")
        if cfm==1:  # Use input arg 3 - Arg1==1 plots the confusion matrix
            disp = plot_confusion_matrix(model, x_use, y_use, cmap=plt.cm.Blues)    # Generate confusion matrix
            print(disp.confusion_matrix)
            plt.show()

        return accuracy     # Returns the accuracy of the model using test data to main file

# Creates SVM
def create_model():
    print("Creating model...")
    clf = svm.SVC(kernel='poly', degree=3, probability=True)    # Create model object using selected parameters

    return clf  # The model object is passed back to the main function

# Train SVM
def train_model(model, x_train, y_train):
    print("Training model...")
    model = model.fit(x_train, y_train)     # Model is trained using x and y train data
    print("Model training finished")

    return model    # The trained model is passed back to the main function

# Testing mdoel
def test_model(model, x_t, y_t):
    print("Testing model...")
    accuracy = model.score(x_t, y_t)    # Model is trained using x and y test data
    print("Model testing finished")

    return accuracy     # The model accuracy is passed back to the main function

# Extract data for usable images
def process(all_index, list_col, y_sel):
    use_list = []   # Empty array to store index of usable images
    max_fn = len(list_col)  # Total number of images
    for i in range(0, max_fn):  # Going through each value in the all_index list
        if all_index[i]==1 or all_index[i]==0:  # If the eye colour is clear or tinted (-1 indicates obscured eye)
            use_list.append(i)  # Generate list containing index for usable images

    use_no = len(use_list)  # Number of usable images
    x_use = []  # Empty array to store extracted x data
    y_use = []  # Empty array to store extracted y data
    for i in range(0, use_no):  # For each usable image
        idx = use_list[i]   # Generate index using use_list
        x_use.append(list_col[idx])     # The colour data from list_col is appended to x. This colour data is previously generated in import_data
        y_use.append(y_sel[idx])    # Append the label data for usable images from the list extracted from the csv (y_eye in main function)

    return x_use, y_use     # Return usable x and y datapoints

# Processes the eye colour if a tint is detected
def col_proc(sample):
    mix_col = sample[-1]    # The colour value of the eye colour mixed with the tint colour
    tint_offset = sample[14]    # The colour value of the pupil (eye black) mixed with the tint
    tint_white = sample[0]  # The colour value of the eye white mixed with the tint
    factor = 255/(tint_white[0]-tint_offset[0])     # The attenuation factor of any colour with a coloured filter
    col = (mix_col-tint_offset)*factor  # The equation for reverting a colour which is filtered through a lens

    return col  # Return the original colour (obtained through processing) back to the import_data function

# Imports csv data. If pickle file is available, imports data, else generates it.
def import_data(directory):
    print("Acquiring labels and slice data...")
    # Directories for each file is generated as each image is in a sub folder of cartoon_set
    full_dir = str(os.path.dirname(__file__)[:-2])+'Datasets/'+directory
    csv_src = os.path.join(full_dir, "labels.csv")
    img_src = os.path.join(full_dir, "img/")

    with open(csv_src) as file:     # Opens the labels.csv file
        dat_read = list(reader(file, delimiter='\t'))   # Data is tab spaced
        labels = list(dat_read)[1:]     # Remove first element of list (headers)

    no_pics = len(labels)   # Total number of pictures
    y_name = []     # List to store the name of each picture
    y_eye = []  # List to store eye colour
    y_shp = []  # List to store face shape
    for i in range(0, no_pics):     # For each picture
        y_name.append(labels[i][3])     # Fourth element is the name
        y_eye.append(labels[i][1])  # Second element is the eye colour
        y_shp.append(int(labels[i][2]))     # Third label is the face shape

    if not os.path.isfile(full_dir+'eyec_data.pickle'):     # If pickle data file containing colour list and ovr_l list doesnt exist
        print("Sample data not found - generating...")
        white = np.array([255,255,255])     # Need a reference to white to compare samples taken
        ovr_l = []  # This list will contain a custom label where -1 represents obscured eyes, 0 represents tinted eyes and 1 represents clear eyes
        col_list = []   # This list will contain the colour value for each eye sample from a specific pixel
        max_fn = len(y_name)    # Total number of images
        for i in range(0, max_fn):  # For each image
            img = cv2.imread(img_src + y_name[i])   # Generating path for each image
            img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)  # Convert colour format from RGB to BGR (cv2 works in BGR)
            sample_n = img[:][263]  # The sample depth is at the 263rd pixel
            sample_n = sample_n[190:216]  # 190th point in slice is eye white for each image, 216th point is eye colour for each image, 204 is black for each image
            mpi = sample_n[int(len(sample_n) / 2)]  # Sample taken at midpoint
            if np.allclose(mpi, sample_n):  # If all rgb values in the sample are equal to the midpoint this means that the eye is obscured
                ovr_l.append(-1)    # Append custom label to list
                col_list.append(None)   # Append 'None' to list that stores the colour of the eye
            else:   # Two other cases left - tinted and clear
                counter = 0     # This counts if white is found in any of the sample pixels
                for n in range(0, len(sample_n)):   # For each pixel in a given sample slice
                    ans = (sample_n[n] == white).all()  # See if any of the pixels match white
                    if ans:
                        counter = counter + 1
                if counter > 0:  # If at least one white pixel is found, this means there is no tint
                    ovr_l.append(1)     # Append custom labels to list
                    col_list.append(sample_n[-1].tolist())  # Append the RGB value of the sample to the colour list
                else:  # The final case left is tinted
                    ovr_l.append(0)     # Append custom label to list
                    colour = col_proc(sample_n)     # The sample_n slice is passed to the processing function to extract the eye colour from the tinted sample
                    col_list.append(colour)     # The RGB value of the processed colour is appended to the colour list
        dat = []    # Empty list to store data which will be pickled
        dat.append(col_list)    # Colour list is appended to empty array
        dat.append(ovr_l)   # Overall list is appended to colour list so single array can be stored in the file
        with open(full_dir+'eyec_data.pickle', 'wb') as f1:     # A pickle file is opened (created if it doesnt exist)
            pickle.dump(dat, f1)    # Dump points data to pickle file

    with open(full_dir+'eyec_data.pickle', 'rb') as f2:     # Open the pickle file containing the slice sample data
        dat = pickle.load(f2)   # Load the file into a variable
        all_index = dat[-1]     # 'Unappend' all_index (aka ovr_l) from combined array.
        list_col = dat[:-1][0]  # Extract colour data from the combined array

    return y_name, y_eye, y_shp, all_index, list_col    # Return data extracted from labels.csv, the index containing custom classification of each image as well as the list of colour values for each image
